# shellcheck shell=sh
# vi:et lbr noet sw=2 ts=2 tw=79 wrap
# Copyright 2020-2022 David Rabkin
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# The script uses local variables which are not POSIX but supported by most
# shells, see more:
#  https://stackoverflow.com/questions/18597697/posix-compliant-way-to-scope-variables-to-a-function-in-a-shell-script
# Disables shellcheck warning about using local variables.
# shellcheck disable=SC3043
#
# shellbase is general framework for POSIX shell scripts. It provides multiple
# services: public functions (logger, validation), signals handlers, garbage
# collection, multiple instances. It asks for a permission to continue if
# multiple running instances of a same script are detected.
#
# shellbase defines global variables and functions. All functions without
# base_ prefix are API and should be used by clients. API functions are:
# be_root, be_user, die, file_exists, is_empty, is_readable, is_writable, log,
# loge, logw, url_exists, validate_cmd, validate_var, var_exists
# yes_to_continue. Global variables have BASE_ prefix and clients could use
# them. Clients should place all temporaly files under $BASE_LCK. All functions
# started with base_ prefix are internal and should not be used by clients.
BASE_IAM=$(basename -- "$0")
BASE_IAM="${BASE_IAM%.*}"
BASE_TMP=/tmp

# busybox implementation of mktemp requires six X.
BASE_LCK=$(mktemp -d "$BASE_TMP/$BASE_IAM.XXXXXX")
BASE_LOG="$BASE_LCK/log"
BASE_BEGIN=$(date +%s)
BASE_VERSION=0.9.20220516
BASE_VERBOSE=false

# Public functions have generic names: log, validate_cmd, yes_to_contine, etc.

# Information logger prints to stdout only with -v (verbose) flag.
log() {
	base_truncate
	if [ "$BASE_VERBOSE" = true ]; then
		base_tim "I $*" | tee -a "$BASE_LOG"
	else
		base_tim "I $*" >> "$BASE_LOG"
	fi
}

# Error logger.
loge() {
	base_truncate
	base_tim "E $*" | tee -a "$BASE_LOG" 1>&2
}

# Warning logger.
logw() {
	base_truncate
	base_tim "W $*" | tee -a "$BASE_LOG" 1>&2
}

# Prints all parameters as error and exits with the error code.
die() {
	loge "$@"
	exit 1
}

# Checks if applications are installed. Loops over the arguments, each one is an
# application name.
validate_cmd() {
	[ -z "${1-}" ] || [ $# -eq 0 ] && die Usage: validate_cmd cmd1 cmd2...
	local arg
	for arg do
		command -v "$arg" >/dev/null 2>&1 || die "Install $arg."
		log "$arg is installed."
	done
}

# Validates if environment variable is set. Returns false if a variable is
# unset or null, returns true if a variable has a value.
var_exists() {
	[ -z "${1-}" ] && die Usage: var_is_set name.
	local var
	set +u
	eval "var=\${$1}"
	set -u
	[ -z "${var}" ] && return 1
	log "$1 is set to $var."
}

# Checks if environment variables are defined. Loops over the arguments, each
# one is a variable name.
validate_var() {
	[ -z "${1-}" ] || [ $# -eq 0 ] && die Usage: validate_var var1 var2...
	local arg
	for arg do
		var_exists "$arg" || die "Define $arg."
	done
}

# Verifies that all parameters are readable files.
is_readable() {
	[ -z "${1-}" ] || [ $# -eq 0 ] && die Usage: is_readable file1 file2...
	local arg
	for arg do
		[ -r "$arg" ] || { loge "$arg is not readable."; return 1; }
	done
}

# Verifies that all parameters are writable files or do not exist.
is_writable() {
	[ -z "${1-}" ] || [ $# -eq 0 ] && die Usage: is_writable file1 file2...
	local arg
	for arg do
		if file_exists "$arg"; then
			[ -w "$arg" ] || { loge "$arg is not writable."; return 1; }
		else
			if ! touch "$arg" 2>/dev/null; then
				loge "$arg is not accessible."
				return 1
			fi
			rm "$arg"
		fi
	done
}

# Exits with error if it is not ran by a user.
be_user() {
	[ -z "${1-}" ] && die Usage: be_user name.
	local ask cur usr="$1"
	cur="$(id -u)"
	ask="$(id -u "$usr" 2>/dev/null)" || die "$usr: no such user."
	[ "$ask" -eq "$cur" ] || die "You are $(id -un) ($cur), be $usr ($ask)."
	log "You are $usr ($cur)."
}

# Exits with error if it is not ran by root.
be_root() {
	be_user root
}

# Asks a user permission to continue, exits if not 'y'. Exits by timeout if any
# input is not detected.
yes_to_continue() {
	local arc
	arc="$(stty -g)"

	# The trap returns tty settings, adds the new line before any printing to
	# compensate the question without a new line.
	local tmo=20
	trap 'stty "$arc"; printf \\n; die "Timed out in $tmo seconds".' TERM

	# Runs watchdog process that kills dad and kids proceeses with common unique
	# process group ID, see minus before dad PID.
	local dad="$$"
	(sleep "$tmo"; kill -- -$dad)&
	local kid="$!"
	log "PIDs: dad $dad, kid $kid."

	# Prints the question without a new line allows to print an answer on the
	# same line. The question is not logged.
	printf 'Do you want to continue? [y/N] '
	stty raw -echo

	# Runs child process to read first character from stdin.
	local ans
	ans=$(head --bytes=1)
	stty "$arc"
	trap base_sig_cleanup TERM

	# Adds the new line before any printing to compensate the question without a
	# new line.
	printf \\n
	log "Killing watchdog kid $kid."
	kill "$kid"

	# Command wait could return an error code, temporarily disables exit on error.
	set +e
	wait "$kid" 2>/dev/null
	set -e
	if printf '%s' "$ans" | grep --ignore-case --quiet '^y'; then
		log Continue working.
		return 0
	fi
	log Stop working.
	exit 0
}

# Decides if a directory is empty. See more:
#  https://www.etalabs.net/sh_tricks.html
is_empty() {
	[ -z "${1-}" ] || [ $# -gt 1 ] && die Usage: is_empty dir.
	cd "$1" >/dev/null 2>&1 || die "Directory is not accessible: $1."
	set -- .[!.]* ; test -f "$1" && return 1
	set -- ..?* ; test -f "$1" && return 1
	set -- * ; test -f "$1" && return 1
	return 0
}

# Checks whether files or directories exist.
file_exists() {
	[ -z "${1-}" ] && die Usage: file_exists filename.
	ls "$1" >/dev/null 2>&1
}

# Checks whether URL exists, any returned HTTP code is OK.
url_exists() {
	[ -z "${1-}" ] && die Usage: url_exists URL.
	validate_cmd curl
	local out
	local url="$1"
	out=$(curl \
		--head \
		--output /dev/null \
		--show-error \
		--silent \
		--write-out '%{http_code}' \
		"$url" \
		2>&1) && { log "$url returns HTTP code $out."; return 0; }

	# In case of error out has two lines: error message and HTTP code 000.
	loge "$url is unavailable. $(printf %s "$out" | head --lines=1)."
	return 1
}

# Private functions have prefix base_, they are used locally.

# Prints timestamp before arguments.
base_tim() {
	printf '%s %s\n' "$(date +"%Y%m%d-%H:%M:%S")" "$*"
}

# Truncates log file in case it is more than 10MB. Do not return in
# functions that are called by signal trap.
base_truncate() {
	[ -w "$BASE_LOG" ] || return 0
	[ "$(wc -c <"$BASE_LOG")" -gt 10485760 ] || return 0
	: > "$BASE_LOG"
	log "$BASE_LOG is truncated."
}

# Formats time titles, the first parameter is a number, the second parameter is
# a time title.
base_time_title() {
	case "$1" in
		0)
			printf ''
			;;
		1)
			printf '%d %s' "$1" "$2"
			;;
		*)
			printf '%d %ss' "$1" "$2"
			;;
	esac
}

# Calculates a separator for time titles based on amount of non-empty
# parameters.
base_time_separator() {
	local cnt=0
	case "$#" in
		1)
			[ -n "$1" ] && cnt=$((cnt+1))
			;;
		2)
			[ -n "$1" ] && cnt=$((cnt+1))
			[ -n "$2" ] && cnt=$((cnt+1))
			;;
		3)
			[ -n "$1" ] && cnt=$((cnt+1))
			[ -n "$2" ] && cnt=$((cnt+1))
			[ -n "$3" ] && cnt=$((cnt+1))
			;;
		*)
			printf 'error: param number is %d: %s.' "$#" "$@"
			;;
	esac
	case "$cnt" in
		0)
			printf ''
			;;
		1)
			printf ' and '
			;;
		2|3)
			printf ', '
			;;
		*)
			printf 'error: counter is %d.' "$cnt"
			;;
	esac
}

# Calculates duration time for report. The first parameter is a start time.
# 86400 seconds in a day, 3600 seconds in an hour, 60 seconds in a minute.
base_duration() {
	local dur="$(($(date +%s)-$1))"
	local d h m s
	d="$(base_time_title $((dur / 86400)) day)"
	h="$(base_time_title $((dur % 86400 / 3600)) hour)"
	m="$(base_time_title $((dur % 86400 % 3600 / 60)) minute)"
	s="$(base_time_title $((dur % 60)) second)"
	if [ -n "$d" ]; then
		printf '%s%s' "$d" "$(base_time_separator "$h" "$m" "$s")"
	fi
	if [ -n "$h" ]; then
		printf '%s%s' "$h" "$(base_time_separator "$m" "$s")"
	fi
	if [ -n "$m" ]; then
		printf '%s%s' "$m" "$(base_time_separator "$s")"
	fi
	if [ -n "$s" ]; then
		printf '%s' "$s"
	fi
	if [ -z "$d" ] && [ -z "$h" ] && [ -z "$m" ] && [ -z "$s" ]; then
		printf 'less than a second'
	fi
}

base_hi() {
	log "$BASE_IAM says hi."
}

base_bye() {
	log "$BASE_IAM says bye after $(base_duration "$BASE_BEGIN")."
}

# General exit handler, it is called on EXIT. Any first parameter means no exit.
base_cleanup() {
	local err=$?
	trap - HUP EXIT INT QUIT TERM
	base_bye

	# Keeps logs of last finished instance.
	local log="$BASE_TMP/$BASE_IAM-log"
	if is_writable "$log"; then
		cp -f "$BASE_LCK/log" "$log"
	fi
	rm -rf "$BASE_LCK"

	# Parameter expantion defines if the parameter is not set, which means exit.
	if [ -z ${1+x} ]; then
		exit $err
	fi
}

# Prevents double cleanup, see more:
#  https://unix.stackexchange.com/questions/57940/trap-int-term-exit-really-necessary
base_sig_cleanup() {
	local err=$?

	# Some shells will call EXIT after the INT handler.
	trap - EXIT
	base_cleanup 1
	exit $err
}

# Asks to continue if multiple instances.
base_check_instances() {
	local ins=0

	# Finds process IDs of all possible instances in /tmp/<script-name.*>/pid and
	# writes them to the pipe. Loop reads the PIDs from the pipe and counts only
	# running processes.
	local pipe="$BASE_LCK/pipe"
	mkfifo "$pipe"
	find "$BASE_TMP/$BASE_IAM".* -name "pid" -exec cat {} \; > "$pipe" &
	while read -r p; do
		kill -0 "$p" >/dev/null 2>&1 && ins=$((ins + 1))
	done < "$pipe"
	rm "$pipe"

	# My instance is running!
	local pid="$BASE_LCK/pid"
	echo $$ > "$pid"

	# Asks permission in case of multiple instances.
	if [ $ins -ne 0 ]; then
		local ending
		if [ $ins -gt 1 ]; then
			ending='es'
		else
			ending='e'
		fi
		printf "%d instanc%s of %s are running.\n" $ins $ending "$BASE_IAM"
		yes_to_continue
	fi
}

# Prints shellbase version and exits.
base_display_version() {
	printf 'shellbase %s\n' "$BASE_VERSION"
	var_exists BASE_APP_VERSION && printf '%s %s\n' "$BASE_IAM" "$BASE_APP_VERSION"
}

# Prints shellbase usage and exits.
base_display_usage() {
	cat <<EOM
Usage: $BASE_IAM [-e] [-h] [-v] [-x]

Arguments:
  -e, --version     Display version number.
  -h, --help        Display this help message.
  -v, --verbose     Echoes log messages to stdout.
  -w, --warranty    Echoes warranty statement to stdout.
  -x, --execute     Echoes every command before execution.
EOM
	var_exists BASE_APP_USAGE && printf %s\\n "$BASE_APP_USAGE"
}

# Prints shellbase warranty.
base_display_warranty() {
	cat <<EOM
Copyright 2020-2022 David Rabkin

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
EOM
}

# Starting point. First loops through command line arguments.
for arg do
	shift
	case "$arg" in
		-e|--version)
			# shellcheck disable=SC2034
			BASE_DISPLAY_VERSION=true
			;;
		-h|--help)
			# shellcheck disable=SC2034
			BASE_DISPLAY_USAGE=true
			;;
		-v|--verbose)
			BASE_VERBOSE=true
			;;
		-w|--warranty)
			# shellcheck disable=SC2034
			BASE_DISPLAY_WARRANTY=true
			;;
		-x|--execute)
			set -x
			;;
		*)
			# Sets back any unused args.
			set -- "$@" "$arg"
	esac
done

# Logs the starting point.
base_hi

# Handles signals, see more:
#  https://mywiki.wooledge.org/SignalTrap
trap base_cleanup EXIT
trap base_sig_cleanup HUP INT QUIT TERM

# Detects previously ran processes with the same name. If found asks to
# continue.
base_check_instances

# The usage has higher priority over version in case both options are set.
if var_exists BASE_DISPLAY_USAGE; then
	base_display_usage
	exit 0
fi
if var_exists BASE_DISPLAY_VERSION; then
	base_display_version
	exit 0
fi
if var_exists BASE_DISPLAY_WARRANTY; then
	base_display_warranty
	exit 0
fi

