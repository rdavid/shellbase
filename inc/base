# shellcheck shell=sh
# vi:ts=2 sw=2 tw=79 et lbr wrap
# Copyright 2020-2022 David Rabkin
#
# The script uses local variables which are not POSIX but supported by most
# shells, see more:
#  https://stackoverflow.com/questions/18597697/posix-compliant-way-to-scope-variables-to-a-function-in-a-shell-script
# Disables shellcheck warning about using local variables.
# shellcheck disable=SC3043
#
# shellbase is general framework for POSIX shell scripts. It provides multiple
# services: functions (be_root, bye, log, validate_cmd, validate_var,
# yes_to_continue), signals handlers, garbage collection, multiple instances. It
# asks for a permission to continue if multiple running instances of a same
# script are detected.
#
# shellbase defines global variables and functions. All functions without
# base_ prefix are API and should be used by clients. API functions are: log,
# loge, bye, validate_cmd, validate_var, be_root, yes_to_continue. Global
# variables have BASE_ prefix and clients could use them. Clients should place
# all temporaly files under $BASE_LCK. All functions started with base_ prefix
# are internal and should not be used by clients.

BASE_IAM=$(basename -- "$0")
BASE_IAM="${BASE_IAM%.*}"
BASE_TMP='/tmp'
BASE_LCK=$(mktemp -d "$BASE_TMP/$BASE_IAM.XXX")
BASE_LOG="$BASE_LCK/log"
BASE_BEGIN=$(date +%s)
BASE_VERSION='0.9.3'
BASE_VERBOSE=false

# Public functions have generic names: log, validate, etc.

# Information logger prints to stdout only with -v (verbose) flag.
log() {
	base_truncate
	if [ "$BASE_VERBOSE" = true ]; then
		base_tim "I $*" | tee -a "$BASE_LOG"
	else
		base_tim "I $*" >> "$BASE_LOG"
	fi
}

# Error logger.
loge() {
	base_truncate
	base_tim "E $*" | tee -a "$BASE_LOG" 1>&2
}

# Warning logger.
logw() {
	base_truncate
	base_tim "W $*" | tee -a "$BASE_LOG" 1>&2
}

# Prints all parameters as error and exits with the error code.
bye() {
	loge "$@"
	exit 1
}

# Checks if applications are installed. Loops over the arguments, each one is an
# application name.
validate_cmd() {
	[ -z "${1-}" ] || [ $# -eq 0 ] && bye 'Usage: validate_cmd cmd1 cmd2 ...'
	local arg
	for arg do
		command -v "$arg" >/dev/null 2>&1 || bye "Install $arg."
		log "$arg is installed."
	done
}

# Checks if environment variables are defined. Loops over the arguments, each
# one is a variable name.
validate_var() {
	[ -z "${1-}" ] || [ $# -eq 0 ] && bye 'Usage: validate_var var1 var2 ...'
	local arg
	for arg do
		set +u
		local var
		eval "var=\${$arg}"
		set -u
		[ -z "${var}" ] && bye "Define $arg."
		log "$arg is defined as $var."
	done
}

# Bye if not root.
be_root() {
	[ "$(id -u)" -ne '0' ] && bye "Run $BASE_IAM with root privileges."
}

# Asks a user permission to continue, exit if not 'y'.
yes_to_continue() {
	# Allows to print an answer on the same line.
	printf 'Do you want to continue? [y/N] '
	local keep
	keep="$(stty -g)"
	stty raw -echo; ans=$(head -c 1); stty "$keep"
	printf '\n'
	printf '%s' "$ans" | grep -iq '^y' || exit 0
}

# Private functions have prefix base_, they are used locally.

# Prints timestamp before arguments.
base_tim() {
	printf '%s %s\n' "$(date +"%Y%m%d-%H:%M:%S")" "$*"
}

# Truncates log file in case it is more than 10MB. Do not return in
# functions that are called by signal trap.
base_truncate() {
	[ -w "$BASE_LOG" ] || return 0
	[ "$(wc -c <"$BASE_LOG")" -gt 10485760 ] || return 0
	: > "$BASE_LOG"
	log "$BASE_LOG is truncated."
}

# Formats time titles, the first parameter is a number, the second parameter is
# a time title.
base_time_title() {
	case "$1" in
		0)
			printf ''
			;;
		1)
			printf '%d %s' "$1" "$2"
			;;
		*)
			printf '%d %ss' "$1" "$2"
			;;
	esac
}

# Calculates a separator for time titles based on amount of non-empty
# parameters.
base_time_separator() {
	local cnt=0
	case "$#" in
		1)
			[ -n "$1" ] && cnt=$((cnt+1))
			;;
		2)
			[ -n "$1" ] && cnt=$((cnt+1))
			[ -n "$2" ] && cnt=$((cnt+1))
			;;
		3)
			[ -n "$1" ] && cnt=$((cnt+1))
			[ -n "$2" ] && cnt=$((cnt+1))
			[ -n "$3" ] && cnt=$((cnt+1))
			;;
		*)
			printf 'error: param number is %d: %s.' "$#" "$@"
			;;
	esac
	case "$cnt" in
		0)
			printf ''
			;;
		1)
			printf ' and '
			;;
		2|3)
			printf ', '
			;;
		*)
			printf 'error: counter is %d.' "$cnt"
			;;
	esac
}

# Calculates duration time for report. The first parameter is a start time.
# 86400 seconds in a day, 3600 seconds in an hour, 60 seconds in a minute.
base_duration() {
	local dur="$(($(date +%s)-$1))"
	local d h m s
	d="$(base_time_title $((dur / 86400)) day)"
	h="$(base_time_title $((dur % 86400 / 3600)) hour)"
	m="$(base_time_title $((dur % 86400 % 3600 / 60)) minute)"
	s="$(base_time_title $((dur % 60)) second)"
	if [ -n "$d" ]; then
		printf '%s%s' "$d" "$(base_time_separator "$h" "$m" "$s")"
	fi
	if [ -n "$h" ]; then
		printf '%s%s' "$h" "$(base_time_separator "$m" "$s")"
	fi
	if [ -n "$m" ]; then
		printf '%s%s' "$m" "$(base_time_separator "$s")"
	fi
	if [ -n "$s" ]; then
		printf '%s' "$s"
	fi
	if [ -z "$d" ] && [ -z "$h" ] && [ -z "$m" ] && [ -z "$s" ]; then
		printf 'less than a second'
	fi
}

base_hi() {
	log "$BASE_IAM says hi."
}

base_bye() {
	log "$BASE_IAM says bye after $(base_duration "$BASE_BEGIN")."
}

# General exit handler, is called on EXIT. Any first parameter means no exit.
base_cleanup() {
	local err=$?
	trap '' EXIT INT TERM
	base_bye
	# Keeps logs of last finished instance. Could be a possible problem.
	cp -f "$BASE_LCK/log" "$BASE_TMP/$BASE_IAM-log"
	rm -rf "$BASE_LCK"
	# Parameter expantion defines if the parameter is not set, which means exit.
	if [ -z ${1+x} ]; then
		exit $err
	fi
}

# Prevents double cleanup, see more:
#		https://unix.stackexchange.com/questions/57940/trap-int-term-exit-really-necessary
base_sig_cleanup() {
	local err=$?
	# Some shells will call EXIT after the INT handler.
	trap '' EXIT
	base_cleanup 1
	exit $err
}

# Asks to continue if multiple instances.
base_check_instances() {
	local ins=0
	# Finds process IDs of all possible instances in /tmp/<script-name.*>/pid and
	# writes them to the pipe. Loop reads the PIDs from the pipe and counts only
	# running processes.
	local pipe="$BASE_LCK/pipe"
	mkfifo "$pipe"
	find "$BASE_TMP/$BASE_IAM".* -name "pid" -exec cat {} \; > "$pipe" &
	while read -r p; do
		kill -0 "$p" >/dev/null 2>&1 && ins=$((ins + 1))
	done < "$pipe"
	rm "$pipe"

	# My instance is running!
	local pid="$BASE_LCK/pid"
	echo $$ > "$pid"

	# Asks permission in case of multiple instances.
	if [ $ins -ne 0 ]; then
		local ending
		if [ $ins -gt 1 ]; then
			ending='es'
		else
			ending='e'
		fi
		printf "%d instanc%s of %s are running.\n" $ins $ending "$BASE_IAM"
		yes_to_continue
	fi
}

# Start point. Loops through command line arguments.
for arg do
	shift
	case "$arg" in
		--help)
			export BASE_SHOW_HELP=true
			;;
		--verbose|-v)
			BASE_VERBOSE=true
			;;
		--version)
			printf 'shellbase %s\n' "$BASE_VERSION"
			export BASE_SHOW_VERSION=true
			;;
		*)
			# Sets back any unused args.
			set -- "$@" "$arg"
	esac
done

base_hi
trap base_cleanup EXIT
trap base_sig_cleanup INT QUIT TERM
base_check_instances
